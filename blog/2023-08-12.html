<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Blog | João Arthur</title><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/d757e479764ebd00.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d757e479764ebd00.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-ac88a2a245aea9ab.js" defer=""></script><script src="/_next/static/chunks/main-52a64d495fc98d1b.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3dff70a4aba63f1d.js" defer=""></script><script src="/_next/static/chunks/2920303b-fa592558efeafade.js" defer=""></script><script src="/_next/static/chunks/989-801fc34bb3939297.js" defer=""></script><script src="/_next/static/chunks/879-83dd8b9762924ec2.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-d4a522b47bc3f313.js" defer=""></script><script src="/_next/static/PUaeASSYjebFwoDMxkRuL/_buildManifest.js" defer=""></script><script src="/_next/static/PUaeASSYjebFwoDMxkRuL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="w-1/3 mx-auto pt-3 pb-8"><nav class="flex justify-around"><a class="px-4" href="/">about</a><a class="px-4" href="/projects">projects</a><a class="underline px-4" href="/blog">blog</a></nav></header><main class="h-full overflow-auto"><div class="prose m-auto"><h1>Thoughts on interfaces</h1>
<h2>Programming types</h2>
<p>Let&#x27;s consider programming in terms of types. For instance, a number can be an integer, a float, or a type with specific precision. A text can be a character, a string, or a binary format with an unspecified size. Likewise, an object&#x27;s behavior can be defined by a type, referred to as an <em>interface</em> in most OOP languages.</p>
<p>An interface defines a set of operations with arguments and return types. This allows for:</p>
<ul>
<li>Polymorphism</li>
<li>Highly decoupled implementations</li>
<li>Plain stub objects</li>
</ul>
<h2>Applying interfaces</h2>
<p>I implemented the PreciseSchedule&#x27;s backend using as many interfaces as possible. In the process, I found out that: <strong>the more interfaces you have, the harder it is to understand the code intentions</strong>. In my case, the goal was to provide a default implementation and a default stub for testing.</p>
<p>When applying this approach to a layered architecture, there is too much indirection. Is is hard to follow the code direction, therefore, the code operations and their results. The code becomes bloated with type definitions and stubs. The tests only assert object interations instead of value assertions. If your programming language doesn&#x27;t make error handling explicit, you will forget to handle an exception sooner or later.</p>
<h2>Alternatives</h2>
<p>What I found is likely something Java developers realized a couple of years ago with libraries like <em>Mockito</em>: rather than using an interface solely for testing purposes, you can mock your code&#x27;s dependencies during runtime testing.</p>
<p>At this point, I&#x27;m inclined to believe that features like <em>Option</em> and <em>Result</em> from the Rust programming language solve the problem of explicitly managing errors and null values in your code.</p>
<p>In the future, I intend to adopt a <em>default approach</em>, creating interfaces only for resources such as databases, random data generation, and HTTP requests.</p></div></main><footer class="flex justify-center pt-2 pb-2 items-center"><a class="mx-3" href="http://github.com/joao-arthur" target="_blank" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="30" width="30" xmlns="http://www.w3.org/2000/svg"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></a><a class="mx-3" href="https://www.linkedin.com/in/joao-lothamer" target="_blank" rel="noopener noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="30" width="30" xmlns="http://www.w3.org/2000/svg"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></a><span class="mx-3 select-none">João Arthur</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"md":"# Thoughts on interfaces\n\n## Programming types\n\nLet's consider programming in terms of types. For instance, a number can be an integer, a float, or a type with specific precision. A text can be a character, a string, or a binary format with an unspecified size. Likewise, an object's behavior can be defined by a type, referred to as an _interface_ in most OOP languages.\n\nAn interface defines a set of operations with arguments and return types. This allows for:\n  - Polymorphism\n  - Highly decoupled implementations\n  - Plain stub objects\n\n## Applying interfaces\n\nI implemented the PreciseSchedule's backend using as many interfaces as possible. In the process, I found out that: **the more interfaces you have, the harder it is to understand the code intentions**. In my case, the goal was to provide a default implementation and a default stub for testing.\n\nWhen applying this approach to a layered architecture, there is too much indirection. Is is hard to follow the code direction, therefore, the code operations and their results. The code becomes bloated with type definitions and stubs. The tests only assert object interations instead of value assertions. If your programming language doesn't make error handling explicit, you will forget to handle an exception sooner or later.\n\n## Alternatives\n\nWhat I found is likely something Java developers realized a couple of years ago with libraries like _Mockito_: rather than using an interface solely for testing purposes, you can mock your code's dependencies during runtime testing.\n\nAt this point, I'm inclined to believe that features like _Option_ and _Result_ from the Rust programming language solve the problem of explicitly managing errors and null values in your code.\n\nIn the future, I intend to adopt a _default approach_, creating interfaces only for resources such as databases, random data generation, and HTTP requests."},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"2023-08-12"},"buildId":"PUaeASSYjebFwoDMxkRuL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>